import code_list_one.*;

public class 第八章 {
    /*
     * 第八章:多态
     * 	·三大基本特征：数据抽象，继承，多态
     * 	·多态的作用是：消除类型之间的耦合关系。不但能改善代码的结构组织和可读性，还可以创建可扩张的程序。
     * 	·多态方法调用允许一种类型表现出于其他相似类型之间的区别，只要它们都是从同一个基类中导出的。
     */

    /*
     * 	·在论向上转型
     * 	  ·对象既可以以自己本身的类型使用，也可以作为它的基类使用
     * 	  ·把一个对象实例用它的基类指引(基类类型作为引用)被称为向上转型。因为在继承树的画法中，基类是放置在上方的。
     */
    Music music;

    /*
     * 	·忘记对象的类型
     * 	  ·接着上面的例子，如果让tune()方法接受一个Wind1引用会更为直观。但是这样做的话，就需要为系统内Instrument1的每一种类型都编写一个新的tune()方法
     * 		·现在再加入Stringed和Brass这两种乐器
     */
    Music2 music2;

    /*
     * ·转机
     * 	·看一个tune方法
     * 		public static void tune(Instrument i) {
     * 			i.play();
     * 		}
     * 	---这里接受Instrument引用的对象，但是编译器是怎么知道Instrument引用指向的是Wind1，Stringed类型还是其他类型
     * 		因为Wind1，Stringed都有一个play方法，编译器是不知道调用的是哪一个对象的play方法。
     *
     * 	·方法调用绑定
     *	  ·将一个方法与一个方法主体(这里应该是指对象)关联起来被称为绑定
     *		·在程序执行前进行绑定，叫前期绑定
     *		·当编译器只有一个Instrument引用，它无法知道调用的是哪个方法。解决办法就是后期绑定
     *		  ·后期绑定：
     *			有一种机制，可以在运行时判断对象的类型，根据对象的类型进行绑定(其实在对象中已经安置了类型的信息，尽管已经向上转型了)，从而调用恰当的方法
     *			也就是说，编译器一直不知道对象的类型，但是  方法调用机制  能找到正确的方法体，并加以调用。
     *	  ·java中除了static方法和final方法(private方法也属于final)之外，其他  所有的方法  都是  后期绑定  的。这意味着通常情况下，我们不必判定是否应该进行后期绑定--它会自动发生的
     *		所以使用final会生成更有效的代码(其实大多数整体性能不会有什么改观)。所以最好是设计来决定是否使用final，而不是性能
     */


    /*
     *	·产生正确的行为
     *	  ·知道java的所有方法都是后期绑定实现多态，我们就可以编写  只与  基类  打交道的代码(划重点)
     */
    Shapes shapes;

    /*
     *	·可扩展性
     *	  ·有了多态机制，可根据自己的需求对系统添加任意多的类型，而不用更改基类的代码，只与基类接口通信(服务端原来的代码也不用更改，因为是针对基类进行编程)。
     *		这样的程序是可扩展的，因为可以在通用的基类继承出新的类型，增加一些新的功能。那么针对基类编程的不需要有任何的改动
     *
     */

    /*
     * 	·缺陷：不能"覆盖"私有方法
     * 	  ·由于private方法被自动认为是final方法，而且对导出类是屏蔽的，private方法是不能被重载的，只有非private方法才能被重载
     */
    PrivateOverride privateOverride;

    /*
     * 	·缺陷：域与静态方法不存在多态
     * 		如果某个类是静态的，它的行为就不具有多态性，静态方法是类，而并非与单个的对象所关联
     */
    FieldAccess fieldAccess;//域不存在多态
    StaticPolymorphism staticPolymorphism;//静态方法不存在多态

    /*
     * ·构造器和多态
     * 	·尽管 构造器不具有多态性(它们实际上是static方法，只不过该static声明是隐式的)，但还是非常有必要理解构造器怎样通过多态在复杂的层次结构中运行
     * 	  ·对象构造过程
     * 		1.调用基类的构造器,这个步骤会不断地反复递归下去。首先调用这种层次结构的根，然后是下一层导出类，直到最底层的导出类
     * 		2.按声明顺序调用成员的初始化方法
     * 		3.调用导出类的构造器
     */
    Sandwich sandwich;//对象构造过程的调用顺序

    /*
     * 	·继承与清理
     * 	  ·通过组合和继承的方式来创建新类时，永远不用担心对象的清理问题，垃圾回收器会处理。
     * 	  ·但是有一些情况真的需要清理的话(例如是调用c/c++之类的)，那么就要为新类创建dispose()方法。由于继承的缘故，在做清理工作时，必须在导出类中覆盖dispose()方法，
     * 		如果导出类也存在需要清理的资源(如果你没有覆盖，基类不可你能帮你清理到的)。同时在导出类的dispose()方法中，必须调用基类的dispose()方法(使用super.dispose())
     * 		因为导出类清理完，必须调用基类的清理工作(因为在导出类创建时，基类的对象就已经创建了，如果你不去显式的配置调用基类，那么基类的清理工作就得不到清理)
     */
    Frog1 frog1;//继承与清理

    /*
     * 	·构造器内部的多态方法的行为(基类构造器中有一个方法，导出类覆盖了，把该方法放在基类的构造器中 调用的是导出类的重写的方法，因为多态的存在)
     * 	  ·如果调用基类的构造器，它的内部一个动态绑定方法，就要用到那个方法被覆盖之后的定义。
     * 		然而，调用的效果是令人难以意料的，因为被覆盖的方法是在导出类对象还没有构造之前就被调用(对象都还没有创建，对象的方法就被调用了，你能想象到吗)。
     *
     *	  另：·构造器只是构建对象过程的一个步骤(构建对象还有成员变量初始化..等等)。构造器只是构建对象过程的最后一个步骤，调用构造器之后对象就被创建了。
     *
     *	·初始化过程
     *	  ·在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零
     *	  ·调用基类的构造器。(下面例子中，调用基类构造器中调用了覆盖后的draw方法)。由于第一条，会发现值是1
     *	  ·按照声明的顺序初始化成员变量
     *	  ·调用导出类的构造器
     *		·这样做有一个好处就是：那就是所有的东西都是零了。如果是对象引用则是null，这会在排除发现问题方面有很大的帮助
     *
     *	·针对构造器内部的多态方法的发生，在编写构造器时有一条有效的准则
     *	  ·用尽可能简单的方法使对象进入正常状态，避免调用其它方法
     *	  ·构造器内唯一安全调用的方法是final方法(private也属于final)，这些方法不会被覆盖，那就不会出现多态
     */
    PolyConstructors polyConstructors;//构造器内部的多态方法

    /*
     * ·协变返回类型
     * 	·在SE 5.0 中添加了协变返回类型，	一句话：覆盖的方法返回值类型不一定要与基类的一样(是其导出类也可以)
     */
    CovariantReturn covariantReturn;

    /*
     * ·向下转型与运行时类识别
     */
    RTTI rtti;


    /*
     * 练习
     */
    Cycle cycle;
    Rodent rodent;
    ObjectJ objectJ;
}
