public class 第一章 {

    /*
     *
     * 第一章:
     *
     * 	·java用三个关键字在类的内部设定边界:public,private,protected
     * 		·public表示紧随其后的元素对任何人都是可用的
     * 		·private除了类型的创建者和类型的内部方法之外的任何人都不可以访问的元素
     * 		·protected与private作用相当，差别在于继承的类可以访问protected成员，但是继承的类不能访问private成员，另外protected还具有包访问权限
     *
     *
     * 	·继承
     * 		·在创建一个类之后，即使另一个新类与其具有相似的功能(但还是有一些不同的地方)，你还是等创建一个新类。
     * 			如果能以现有的类为基础，复制它，然后通过添加和修改这个 副本 来创建新类就要好多了。
     * 			通过继承就可以达到这种效果，不过也有例外，当源类(被称为基类，超类或父类)发生变动时，"被修改的副本"(被称为导出类，继承类，或子类)也会变动
     *
     * 		·类型不仅仅只是描述了作用于一个对象集合上(一个类就是各种元素集合组成(也就是对象集合))，同时还有与其他类型之间的关系
     * 		·一个基类包含其所有导出类型所共享的特性和行为，可以创建一个基类型来表示某些对象的核心概念，从基类中导出其他类型，来表示此核心可以被实现的各种不同方式
     * 			(以垃圾回收机为例)，用来归类散落的垃圾，"垃圾"是基本类型，可以通过添加额外的特征(瓶子有颜色)或行为(铁罐可以被磁化)导出更具体的垃圾类型
     * 			(以几何形为例子)，几何形可以包含圆形，多边形等，而多边形也包含正方形，长方形(所有基类就是几何形，派生出很多导出类，这样看起来非常有层次感)
     * 			·可以通过使用继承来构建一个类型层次结构(已不仅仅是为了继承基类中的内容)，通过继承来建立一个庞大的体系，而看起来是非常有层次结构的
     *
     * 		·所有可以发送给基类的信息同时也可以发送给导出类对象，导出类与基类具有相同的类型。(上面的例子，圆形和多边形(导出类)都属于几何形(基类))
     *
     *		·两种方法是基类与导出类产生差异
     *			·非常直接，在导出类中添加新方法(这些方法不是基类中的一部分)，这意味中基类不能满足你的所有需求，因此必须额外添加更多额外的方法
     *			·但是有时候也应该仔细的考虑，是否存在可以把这些额外的方法再次抽象到基类中。(在这很大程度上就会引发使用下面的 "覆盖":重写基类的方法)
     *				"覆盖"(在使用extends关键字表示继承的java中):改变基类中方法的行为(方法名不变，在导出类中实现)，使导出类和基类之间产生差异(使之满足导出类的需求)
     *				要想覆盖某个方法，可以直接在导出类中建该方法的新定义即可(因为使用extends继承并不一定要实现基类中的所有方法，而是覆盖需要改变的方法即可)
     *
     *
     *	·伴随多态的可互换对象
     *		·在处理类型的层次结构时，经常想把一个对象不当作它所属的特定类型对待，而是将其当作其基类的对象对待。这使得人们可以编写出不依赖于特定类型的代码
     *
     *		·一个非面向对象编程的编译器产生的函数调用会引起所谓的 "前期绑定"，这么做意味着编译器将产生对一个具体函数名字的调用，
     *			而运行时将这个调用解析到将要执行的代码的绝对地址
     *		·在面向对象中，程序直到运行时才能够确定代码的地址，所以当信息发送到一个泛化对象时(它并不知道具体的实现类是哪一个，调用的是那个类的方法)
     *			为了解决这个问题，面向对象程序设计语言使用了 后期绑定 的概念。当向对象发送消息时，被调用的代码直到运行时才能确定下来。
     *			编译器要确保被调用的方法存在，并对调用参数和返回值执行类型检查，但是并不知道将执行的确切代码
     *			·为了执行后期绑定，java使用一小段特殊的代码来代替绝对地址调用，这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，
     *			每一个对象都可以具有不同的行为表现。当向每一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。
     *
     *		·把导出类看作是它的基类的过程称为向上转型。
     *
     *
     *	·单继承结构
     *		·在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是一个基本类型(Object)
     *		·单根继承结构中保证所有对象都具备某些功能。因此，你知道在你的系统中每个对象有那些操作
     *		·单根继承结构使垃圾回收器的实现变得容易得多(这正是java相对c++的重要改进之一)
     *
     *
     *	·容器(也称集合)
     *		·在某些类库中，一两个通用的容器足够满足所有的需要，但是在其他类库中(例如java中)，具有满足不同需要的各种容器
     *			例如:List(用于存储序列)，Map(也称为关联数组，用来建立对象之间的关联)，Set(每种对象类型只持有一个)
     *				多个容器可以满足多个需求,还是需要对容器有是所选择，这里有两个原因:
     *					·不同容器提供了不同类型的接口和外部行为
     *					·不同的容器对于某些操作具有不同的效率(例如ArrayList访问元素快  ，LinkedList增删元素快)
     *
     *
     *	·参数化类型
     *		·历史原因:
     *			在SE5.0之前，容器存储的对象都只具有java的通用类型:Object。单根继承结构意味着所有东西都是Object类型，所有该容器可以存储任何东西
     *			但是由于容器只存储Object，所以当将对象引入容器时，它必须被向上转型为Object，因此它丢失了身份，将它取出时取到的是一个Object引用
     *			必须将该Object向下转型为更具体的类型。这种转型方式称为向下转型。向上转型是安全的，但是向下转型是不安全的(因为它不知道你具体的实现类是哪一个)
     *
     *		·那么是否能创建一个容器，它知道自己所保存的对象类型，从而不需要向下转型以及消除犯错误的可能。
     *			这样的解决方案被称为参数化类型机制，参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如使用参数化类型，编译器可以定制一个只接受和取出Dog对象的容器
     *
     *		·SE5.0 的重大变化之一就是增加了参数化类型，在java中称为泛型。一对<>，中间包含类型信息。例如可以用下面这样的语句来创建一个存储Dog的ArrayList的容器
     *			ArrayList<Dog> list = new ArrayList<Dog>();
     *
     *
     *	·对象的创建和生命周期
     *		·对象的数据位于何处?怎样控制对象的生命周期?C++认为 效率 控制最重要的议题，所以给程序员提供了选择的权力。
     *			为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序是确定，这可以通过将对象置于堆栈或静态存储区域来实现。
     *			这种方式将  存储空间分配和释放  放置于优先考虑的位置，在某些情况下这样的控制非常有价值。但是，也牺牲了灵活性，
     *			因为必须在编写程序时知道对象的确切的数量，生命周期和类型。
     *		·还有一种方式被称为  堆的内存池  中动态地创建对象(动态内存分配方式)。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期以及类型是什么。
     *			这些问题只能在程序运行时相关代码被执行到的那一刻才能确定。
     *			如果需要一个新的对象，可以在需要的时刻直接在 堆 中创建。因为存储空间是在运行时被动态管理的，所以需要大量的时间在 堆 中分配存储空间，
     *			但这可能要远远大于在 堆栈 中创建存储空间的时间(C++就是采用这种时间比较快的方式)
     *		·java完全采用动态内存分配方式。每当想要创建新对象时，就要使用new关键字来构建此对象的动态实例
     *		·还有一个议题，就是对象生命周期。
     *			对于允许在 堆栈 上创建对象的语言，编译器可以确定对象存活时间，并自动销毁它。
     *			然而在  堆  上创建对象，编译器就会对它的生命周期一无所知。在C++这样的语言中，必须通过编程的方式来确定何时销毁对象，不能正确处理可能会导致内存泄漏(C++常见的问题)
     *			java提供了"垃圾回收器"的机制，它可以自动发现对象何时不再使用，并销毁它。这种机制减少了考虑的议题和必须编写的代码，更重要是提供更高层的保障，可避免暗藏的内存泄漏
     *		·java的"垃圾回收器"被设计用来处理内存释放问题，它知道对象何时不再使用，并自动释放对象占用的内存
     *			这一点是由于  所有对象都是继承自单根基类Object 以及 只能以一种方式创建对象(在堆上创建)  这两个特性结合起来，使得用java编程的过程较之用c++要简单得多
     *
     *
     *	·异常处理:处理错误
     *		·异常是一种对象，它从出错地点被抛出，并  被  专门设计用来处理特定类型错误相应的异常处理器 "捕获"。
     *		·异常处理就像是  与  程序正常执行路径  并行的，在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，不会干扰到正常的代码
     *			这往往使得代码代码编写的简单，因为不需要被迫定期检查错误。此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。
     *		·异常不能被忽略，所以它保证一定会在某处等到处理。最后需要指出的是:异常提供了一种从错误状况进行可靠恢复途径。现在不再是只能退出程序，
     *			你可以经常进行校正，并恢复程序的执行，这些都有助于编写出更健壮的程序。
     *		·java异常处理在众多的编程语言中格外引人注目，因为java一开始就内置了异常处理，并强制你必须使用它。它是唯一可接受的错误报告方式。
     *			如果没有编写正确的处理异常代码，那么就会得到一条编译时的出错信息。这种有保障的一致性有时会使错误处理非常容易
     *		·值得注意的是，异常处理不是面向对象的特征--尽管在面向对象语言中异常常被表示成为一个对象。异常处理在面向对象语言出现之前就已经存在了。
     */


}
