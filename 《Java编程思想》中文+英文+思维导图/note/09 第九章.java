import code_list_two.*;
import test.Factories;

public class 第九章 {


    /*-
     * 第九章：接口
     * 	·抽象类和抽象方法
     * 	  ·抽象类的目的是为它的所有导出类创建一个通用的接口。建立这个通用接口的唯一理由是：不同的子类可以用不同的方式表示此接口。
     * 		通用接口建立起一种形式，以此表示所有导出类的的共同部分，并称为抽象基类(或者是抽象类)。
     * 	  ·那么抽象类的对象就没有任何的意义了(抽象类里面没有具体的实现)，并且编译器阻止你这样做
     * 	·java提供一个叫做  抽象方法  的机制，这种方法是不完整的，只有声明而没有方法体
     * 		abstract void f();
     * 	  ·包含抽象方法的类叫做抽象类，就算只有一个该类也必须被定义为抽象类
     * 	  ·如果从一个抽象类继承，并想为创建该新类的对象，那么就必须为基类中的所有抽象方法提供具体的实现。
     * 		如果不这样做，那么导出类也必须定义为抽象类，且编译器将会强制我们使用abstract关键字来限定这个类。
     * 	·一个没有任何抽象方法的类也可以被定义为抽象类(这样可以阻止创建该类的对象)
     */
    Music4 music4;//抽象类

    /*
     * 	·接口(interface)
     * 	  ·interface是一个完全抽象的类，根本没有提供任何具体的实现，只是提供形式(允许创建者确定方法名，参数列表和返回值类型)
     * 	  ·interface不仅是一个极度抽象的类，它还允许  导出类向上转型  为  多种基类的类型  (如果一个类实现了多个接口的话)
     * 	  ·创建一个接口，需要用interface来代替class。可以在interface前面加上public，不加public的话这个接口类就是包访问权限
     * 	  ·接口可以创建域，但是这些域都是隐式地是static和final
     * 	  ·使用implements实现接口
     * 	  ·接口中的所有方法都是public，无论你有没有显式的配置出来
     */

    /*
     *	·java中的多重继承
     *	  ·只能继承一个类，但可以实现多个接口。继承写在接口的前面，接口名都置于implements后面，多个接口用逗号隔开。
     *		class A extends B implements C, D{}
     *	  ·可以继承任意多个接口，并一个类可以向上转型为多个类型，因为每一个接口都是一个独立的类型
     *	  ·
     */
    Adventure adventure;//一个类实现多个接口

    /*
     * ·通过继承来扩充接口
     * 	·通过继承，可以通过  原有接口  的基础上 扩充一个新的接口(使用extends关键字)
     * 	·extends多继承只适合接口继承。一般情况，extends只能继承单一类，但是可以实现多个接口。
     */
    HorrorShow horrorShow;

    /*
     * ·组合接口时的名字冲突
     * 	·在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱(比如接口A和接口B都有a方法)，请尽量避免这样做。
     */
    ObjectF objectF;

    /*
     * ·适配接口(这里是一个设计模式，以后要看看)
     * 	·
     */

    /*
     * ·接口中的域
     * 	·放进接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的用来创建常量组的工具。(在枚举类型出现之前/SE5.0之前)
     *
     * 	·初始化接口中的域
     * 	  ·在接口中定义的域不能是"空final"，但是可以使用表达式来初始化
     */
    Months months;//接口中创建常量
    TestRandVals testRandVals;//接口中的域

    /*
     * ·嵌套接口
     *	·接口可以嵌套到类或其他接口中
     *	·当实现某个接口时，并不需要实现嵌套在其内部的任何接口
     */
    NestingInterfaces nestingInterfaces;

    /*
     *	·接口与工厂(工厂设计模式)
     *	  ·生成  遵循某个接口的对象  的典型方式就是工厂方法设计模式。这与直接调用构造器不同，而是直接调用方法(方法内部有创建对象的代码)，
     */
    Factories factories;

    /*
     * 练习
     */
    ObjectA objectA;
    ObjectB objectB;
    ObjectC objectC;
    ObjectD objectD;
    ObjectG objectG;
    ObjectE objectE;
    ObjectH objectH;

}
